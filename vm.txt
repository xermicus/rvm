16bit:
1x 4bit for register
1x 4bit instructions
1x 8bit for value

registers: 
	r0	0	general purpose registers
	r1	1	general purpose registers
	r2	2	general purpose registers
	r3	3	general purpose registers
	r4	4	general purpose registers
	r5	5	general purpose registers
	r6	6	general purpose registers
	r7	7	general purpose registers
	rn	8	next instruction
	rd	9	data pointer
	rf	A	flag register: 0=, 1<, 2>
	rc	B	conditional register: 0=, 1<, 2>
	hlt	C	interrupt halt
	sys 	D	interrupt syscall

instructions:
	opcode  #	target	value	description
	int	0	hlt|sys	null	interrupt: 0 = hlt, 1 = syscall	
	set	1	rX	u8	load value into register
	psh	2	r0-7	u8	push value from register r0 .. r7 to data section (pointer @rd). value is optional (default 1) to store multiple registers. increases rd for free
	pop	3	r0-7	u8	pop value from data section. analog to psh
	add	4	rX	rX	addition, result in target
	sub	5	rX	rX	subtraction, result in target
	mul	6	rX	rX	multiplication, result in target
	div	7	rX	rX	division, result in target
	chk	8	rX	rX	compare, sets flag register
	cns	9	rX	rX	conditional set: set register depending on rf to value according to cr. eg: (chk r0, r1; set rc 0; cns rn 37) will set rn to 37 if r0 = r1
	lpt	A	rX	rX	load pointer
	lsh	B	rX	rX	left shift
	rsh	C	rX	rX	right shift
	and	D	rX	rX	bitwise and
	bor	E	rX	rX	bitwise or
	xor	F	rX	rX	bitwise xor

